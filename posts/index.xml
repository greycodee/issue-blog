<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Issues Blog</title><link>https://blog.greycode.top/issues-blog/posts/</link><description>Recent content in Posts on Issues Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Mar 2023 06:40:54 +0000</lastBuildDate><atom:link href="https://blog.greycode.top/issues-blog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>安装 zsh、oh-my-zsh、powerlevel10k</title><link>https://blog.greycode.top/issues-blog/posts/44/</link><pubDate>Mon, 20 Mar 2023 06:40:54 +0000</pubDate><guid>https://blog.greycode.top/issues-blog/posts/44/</guid><description>安装 zsh 首先执行下面命令
$ zsh --version zsh 5.9 (x86_64-pc-linux-gnu) 如果输出了 zsh 的版本号，则说明已经安装了 zsh 可以跳过此步骤
Manjaro 安装命令
sudo pacman -S zsh 更多安装命令请查看：https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH#how-to-install-zsh-on-many-platforms
设置默认 Shell 为 zsh 查看当前SHELL
$ echo $SHELL /bin/bash Manjaro 设置命令：
$ chsh -s $(which zsh)</description></item><item><title>什么是 FFI ？</title><link>https://blog.greycode.top/issues-blog/posts/9/</link><pubDate>Sat, 18 Mar 2023 06:36:52 +0000</pubDate><guid>https://blog.greycode.top/issues-blog/posts/9/</guid><description>编辑修改测试</description></item><item><title>在 Shell 脚本中使用 jq 解析 json 数据</title><link>https://blog.greycode.top/issues-blog/posts/42/</link><pubDate>Fri, 17 Mar 2023 09:08:51 +0000</pubDate><guid>https://blog.greycode.top/issues-blog/posts/42/</guid><description>0x1 在编写 Shell 脚本时，如果需要解析 json 数据时，可以使用第三方工具库 jq 来解析 官网地址：https://stedolan.github.io/jq/
0x2 安装 Debian and Ubuntu repositories. Install using sudo apt-get install jq Fedora repository. Install using sudo dnf install jq openSUSE repository. Install using sudo zypper install jq Arch repository. Install using sudo pacman -S jq Homebrew to install with brew install jq MacPorts to install with port install jq &amp;hellip;更多请查看官方文档 0x3 使用 假如有一个文件 data.json ，内容如下：
{ &amp;#34;name&amp;#34;: &amp;#34;greycode&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34; } 可以使用如下命令解析：</description></item><item><title>nginx 配置反向代理后响应502解决办法</title><link>https://blog.greycode.top/issues-blog/posts/1/</link><pubDate>Fri, 17 Mar 2023 14:58:25 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/1/</guid><description>问题 在配置反响代理到本地 127.0.0.1:7788 这个地址后，请求 nginx 地址响应 502 查看 /var/log/nginx/error.log 日志文件提示如下：
2022/11/19 08:51:11 [crit] 4210#0: *1 connect() to 127.0.0.1:7788 failed (13: Permission denied) while connecting to upstream, client: 20.222.186.137, server: ntfy.greycode.top, request: &amp;#34;GET / HTTP/1.1&amp;#34;, upstream: &amp;#34;http://127.0.0.1:7788/&amp;#34;, host: &amp;#34;test.com&amp;#34; 解决 根据stackoverflow的回答，执行如下命令解决问题
setsebool -P httpd_can_network_connect 1</description></item><item><title>Oracle Cloud 实例开启端口访问</title><link>https://blog.greycode.top/issues-blog/posts/2/</link><pubDate>Fri, 17 Mar 2023 14:58:25 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/2/</guid><description> 原文：https://blog.csdn.net/austin1000/article/details/125840927
原因 Oracle Cloud vps建立成功后，在 VNIC 子网中安全组中配置了端口还是无法访问。
解决办法 在 VNIC 子网中配置安全组，开启外部需要访问的端口。 然后关闭系统防火墙
ubuntu # 开放所有端口 iptables -P INPUT ACCEPT iptables -P FORWARD ACCEPT iptables -P OUTPUT ACCEPT iptables -F # 删除防火墙 apt-get purge netfilter-persistent &amp;amp;&amp;amp; reboot 或 rm -rf /etc/iptables &amp;amp;&amp;amp; reboot Centos # 删除多余附件 systemctl stop oracle-cloud-agent systemctl disable oracle-cloud-agent systemctl stop oracle-cloud-agent-updater systemctl disable oracle-cloud-agent-updater # 关闭防火墙并禁止自启动 systemctl stop firewalld.service systemctl disable firewalld.service</description></item><item><title>使用 ab 命令对 http 服务进行压测</title><link>https://blog.greycode.top/issues-blog/posts/4/</link><pubDate>Fri, 17 Mar 2023 14:58:25 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/4/</guid><description>ab命令全称为：Apache bench 。是Apache自带的压力测试工具。ab命令非常实用，它不仅可以对Apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。可以测试安装Web服务器每秒种处理的HTTP请求。
使用 Go 创建一个简单的 http 接口 package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/hello&amp;#34;, func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&amp;#34;Hello World&amp;#34;)) }) err := http.ListenAndServe(&amp;#34;:8888&amp;#34;, nil) if err != nil { log.Fatalf(&amp;#34;ListenAndServe: %v&amp;#34;, err) } } 使用 ab 命令进行压测 # 并发 1 00 个连接，共 10000 个请求 ab -n 10000 -c 100 http://localhost:8888/hello 结果：
This is ApacheBench, Version 2.3 &amp;lt;$Revision: 1901567 $&amp;gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.</description></item><item><title>使用certbot</title><link>https://blog.greycode.top/issues-blog/posts/3/</link><pubDate>Fri, 17 Mar 2023 14:58:25 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/3/</guid><description> 1 dnf install certbot 2 yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-8.noarch.rpm 3 dnf install certbot 4 dnf install python3-certbot-nginx 5 dnf install nginx 6 nginx 7 systemctl stop oracle-cloud-agent 8 systemctl disable oracle-cloud-agent 9 systemctl stop oracle-cloud-agent-updater 10 systemctl disable oracle-cloud-agent-updater 11 systemctl stop firewalld.service 12 systemctl disable firewalld.service 13 certbot --nginx -d bark.greycode.top 14 history</description></item><item><title>Docker 客户端(Linux)配置代理 pull 镜像</title><link>https://blog.greycode.top/issues-blog/posts/11/</link><pubDate>Fri, 17 Mar 2023 14:58:24 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/11/</guid><description>原因 身处墙国，拉取镜像非常慢，所以要设置代理来提升拉取镜像的速度。
设置方法 创建文件夹 $ sudo mkdir -p /etc/systemd/system/docker.service.d 新建配置文件 $ sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf 填入代理配置：
[Service] Environment=&amp;#34;HTTP_PROXY=http://127.0.0.1:7890&amp;#34; Environment=&amp;#34;HTTPS_PROXY=http://127.0.0.1:7890&amp;#34; Environment=&amp;#34;NO_PROXY=your-registry.com,10.10.10.10,*.example.com&amp;#34; 如果你自己建了私有的镜像仓库，需要 dockerd 绕过代理服务器直连，那么配置 NO_PROXY 变量，多个 NO_PROXY 变量的值用逗号分隔，而且可以使用通配符（*），极端情况下，如果 NO_PROXY=*，那么所有请求都将不通过代理服务器。如果不需要可以直接不设置这个变量
重启服务 $ sudo systemctl daemon-reload $ sudo systemctl restart docker 检查配置 $ sudo systemctl show --property=Environment docker [sudo] password for zheng: Environment=HTTP_PROXY=http://127.0.0.1:7890 HTTPS_PROXY=http://127.0.0.1:7890 设置成功🎉</description></item><item><title>Nginx Process Model</title><link>https://blog.greycode.top/issues-blog/posts/12/</link><pubDate>Fri, 17 Mar 2023 14:58:24 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/12/</guid><description>Introduction Nginx adopts a unique master and multi workers process pool mechanism, which guarantees stable operation and flexible configuration of Nginx. Usually, Nginx will start a master process and multiple worker processes to provide external services. The master process, known as the monitoring process, did not handle specific TCP/HTTP requests and received only the Unix signal. Worker processes compete equally for accepting client connections, executing the main business logic of Nginx, and Using epoll, kqueue, and other mechanisms to process TCP/HTTP requests efficiently.</description></item><item><title>OpenResty 安装入门教程</title><link>https://blog.greycode.top/issues-blog/posts/8/</link><pubDate>Fri, 17 Mar 2023 14:58:24 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/8/</guid><description>方法1: [推荐] 源码编译安装 去下载页面下载源码包,然后执行下面的命令进行解压,编译和安装
tar -xvf openresty-VERSION.tar.gz cd openresty-VERSION/ ./configure -j2 make -j2 sudo make install # better also add the following line to your ~/.bashrc or ~/.bash_profile file. export PATH=/usr/local/openresty/bin:$PATH 方法2: 在 ArchLinux 安装 在官方预编译包列表中，没有编译 ArchLinux 的包，所以我们可以直接使用 yay 包管理器来安装，可以看AUR地址 首先要在电脑上安装 yay 包管理器，然后执行下面的命令进行安装：
yay -S openresty 等命令执行完，按提示在你的环境变量文件中添加 OpenResty 的安装路径，就添加下面这一行到你的环境变量配置文件中
export PATH=/opt/openresty/bin:$PATH 然后激活一下环境变量，就安装成功了
OpenResty 命令介绍 ╰─$ sudo openresty -h [sudo] password for zheng: nginx version: openresty/1.21.4.1 Usage: nginx [-?hvVtTq] [-s signal] [-p prefix] [-e filename] [-c filename] [-g directives] Options: -?</description></item><item><title>Raft 共识算法</title><link>https://blog.greycode.top/issues-blog/posts/10/</link><pubDate>Fri, 17 Mar 2023 14:58:24 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/10/</guid><description>null</description></item><item><title>vite 项目配置跨域代理</title><link>https://blog.greycode.top/issues-blog/posts/13/</link><pubDate>Fri, 17 Mar 2023 14:58:24 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/13/</guid><description>在 vite.config.ts 文件下添加如下配置
server: { cors: true, // 默认启用并允许任何源 proxy: { &amp;#39;/api&amp;#39;: { target: &amp;#39;http://192.168.1.2:8001/&amp;#39;, changeOrigin: true, rewrite: (path) =&amp;gt; path.replace(/^\/api/, &amp;#39;&amp;#39;) }, } } 文件全文：
import { defineConfig } from &amp;#39;vite&amp;#39; import react from &amp;#39;@vitejs/plugin-react&amp;#39; // https://vitejs.dev/config/ export default defineConfig({ plugins: [react()], server: { cors: true, // 默认启用并允许任何源 proxy: { &amp;#39;/api&amp;#39;: { target: &amp;#39;http://192.168.1.2:8001/&amp;#39;, changeOrigin: true, rewrite: (path) =&amp;gt; path.replace(/^\/api/, &amp;#39;&amp;#39;) }, } } })</description></item><item><title>使用 http_load 对 http 服务进行压测</title><link>https://blog.greycode.top/issues-blog/posts/5/</link><pubDate>Fri, 17 Mar 2023 14:58:24 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/5/</guid><description>安装 # macOS brew install http_load 或则直接去 http://www.acme.com/software/http_load/ 下载
使用 现定一个文本文件，里面放上要压测 url
urls.txt
http://localhost:8888/hello 执行命令
http_load -p 50 -s 5 urls.txt -p 50 命令表示50个连接进程，-s 5 表示持续 5 秒
结果：
16284 fetches, 50 max parallel, 179124 bytes, in 5.00497 seconds 11 mean bytes/connection 3253.56 fetches/sec, 35789.2 bytes/sec msecs/connect: 2.44797 mean, 862.047 max, 0.098 min msecs/first-response: 2.30903 mean, 861.732 max, 0.116 min HTTP response codes:</description></item><item><title>小米(umi)使用 fastboot 刷机</title><link>https://blog.greycode.top/issues-blog/posts/6/</link><pubDate>Fri, 17 Mar 2023 14:58:24 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/6/</guid><description>执行过程 直接在终端命令行使用 fastboot 命令进行刷机(手机需先申请解锁)
在设置中打开 USB 调试，然后连接电脑 执行命令 adb reboot bootloader 进入fastboot 模式 下载 MIUI 线刷包，解压后，执行 flash_all.sh 命令 等待刷机完成</description></item><item><title>小米(umi)刷入 Magisk</title><link>https://blog.greycode.top/issues-blog/posts/7/</link><pubDate>Fri, 17 Mar 2023 14:58:24 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/7/</guid><description>首先要确定当前手机的ROM版本，然后下载对应的线刷包
解压线刷包，然后进入解压后的文件夹里，上上传 images 文件夹下的 boot.img 文件到手机 可以直接使用 adb 命令上传
adb push boot.img /storage/self/primary 然后到 Magisk Release 下载最新版本APP，上传到手机安装 手机进入 Magisk App，点击第一个 Magisk 模块上的安装（不要勾选 vbmeat相关选项），点击选择一个补丁，选择刚才上传的 boot.img 文件。 此时会执行编译，然后记下App界面上出现保存编译后的文件地址，执行命令保存到电脑上
adb pull /storage/emulated/0/Download/magisk_patched-25200_UpxP7.img 电脑执行命令，手机进入 fastboot 模式
adb reboot bootloader 然后刷入刚才的文件
fastboot flash boot magisk_patched-25200_UpxP7.img 刷入完成后就可以重启手机了 complete!</description></item><item><title>coc.nvim 插件安装</title><link>https://blog.greycode.top/issues-blog/posts/17/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/17/</guid><description>简介 开源地址：coc.nvim 能够在 neovim 中编写代码时，像IDE一样弹出代码提升并可以自动补全
环境要求 neovim &amp;gt;= 0.4.0. nodejs &amp;gt;= 14.14 安装插件 使用 Packer 安装 coc.nvim 插件，只要在~/.config/nvim/lua/plugins.lua文件中添加如下配置
use {&amp;#39;neoclide/coc.nvim&amp;#39;, branch = &amp;#39;release&amp;#39;} full content of ~/.config/nvim/lua/plugins.lua
vim.cmd [[packadd packer.nvim]] return require(&amp;#39;packer&amp;#39;).startup(function() -- Packer can manage itself use &amp;#39;wbthomason/packer.nvim&amp;#39; -- 添加 coc.vim 插件 use {&amp;#39;neoclide/coc.nvim&amp;#39;, branch = &amp;#39;release&amp;#39;} end) 然后执行命令,等待安装完成✅
nvim +PackerSync 配置 coc.nvim 插件 完成安装后，只是能够简单的提示，这里还需要安装 languageServer，这里以安装 Go 语言提示为例
more Language Server 在 nvim 界面中，执行如下命令
:CocInstall coc-go 看到绿色小勾就说明安装成功了 然后在 nvim 界面中，输入如下命令，进入 coc.</description></item><item><title>coc.nvim 配置 Rust 代码提醒补全</title><link>https://blog.greycode.top/issues-blog/posts/18/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/18/</guid><description>安装 coc-rust-analyzer
安装 rust-analyzer
$ git clone https://github.com/rust-lang/rust-analyzer.git &amp;amp;&amp;amp; cd rust-analyzer $ cargo xtask install --server 配置 coc-setting.conf { &amp;#34;languageserver&amp;#34;: { &amp;#34;golang&amp;#34;: { &amp;#34;command&amp;#34;: &amp;#34;gopls&amp;#34;, &amp;#34;rootPatterns&amp;#34;: [&amp;#34;go.mod&amp;#34;], &amp;#34;filetypes&amp;#34;: [&amp;#34;go&amp;#34;] }, &amp;#34;rust&amp;#34;: { &amp;#34;command&amp;#34;: &amp;#34;rust-analyzer&amp;#34;, &amp;#34;filetypes&amp;#34;: [&amp;#34;rust&amp;#34;], &amp;#34;rootPatterns&amp;#34;: [&amp;#34;Cargo.toml&amp;#34;] } }, &amp;#34;rust-analyzer.serverPath&amp;#34;: &amp;#34;~/.cargo/bin/rust-analyzer&amp;#34; } rust-analyzer.serverPath 配置成 rust-analyzer 安装的路径</description></item><item><title>Docker 构建镜像时设置网络代理</title><link>https://blog.greycode.top/issues-blog/posts/21/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/21/</guid><description>构建镜像时，需要连接网络下载外网数据时，这时候就需要设置网络代理
首先开启你的代理软件，获取代理软件的监听地址。例如我用的是 Clash，它的监听地址是 http://127.0.0.1:7890 在执行 docker build 命令构建时，添加 --build-arg 参数 例如： --build-arg HTTP_PROXY=http://127.0.0.1:1080 完整命令 docker build \ --network host \ --build-arg HTTP_PROXY=http://127.0.0.1:7890 --build-arg HTTPS_PROXY=http://127.0.0.1:7890 \ -t xxx:1.0 .</description></item><item><title>lldb 添加 python 脚本</title><link>https://blog.greycode.top/issues-blog/posts/22/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/22/</guid><description>新键一个 python 脚本 ~/htlloworld.py
输入如下内容：
def helloworld(debugger, command, result, internal_dict): print(&amp;#34;hello world!&amp;#34;) lldb 手动导入 python 脚本 $ lldb (lldb) command script import ~/helloworld.py (lldb) command script add -f helloworld.helloworld hello (lldb) hello hello world! lldb 自动导入 pyhon 脚本 在 ~/htlloworld.py 添加如下内容
def __lldb_init_module(debugger, internal_dict): debugger.HandleCommand(&amp;#39;command script add -f helloworld.helloworld hello&amp;#39;) 然后在 ~/.lldbinit 文件（如果没这个文件就创建一个）里添加如下内容:
command script import /Users/zheng/coding/test/helloworld.py 这样打开 lldb 直接输入 hello 命令就可以执行这个脚本了</description></item><item><title>neovim 命令速记</title><link>https://blog.greycode.top/issues-blog/posts/20/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/20/</guid><description>更多可以查看vim文档
窗口大小设置
:vertical resize +10 窗口垂直宽度加10
:vertical resize -10 窗口垂直宽度减10
:horizontal resize +10 窗口水平宽度加10
:horizontal resize -10 窗口水平宽度减10
打开终端
:bel split | terminal or :belowright split | terminal 在窗口上分割一个窗口来打开新终端</description></item><item><title>neovim 和 packer 包管理器安装</title><link>https://blog.greycode.top/issues-blog/posts/16/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/16/</guid><description>安装 neovim ArchLinux sudo pacman -S neovim 更多安装方式查看官方安装文档
安装 packer 包管理器 我们可以使用 packer 来管理 neovim 的插件
Unix/Linux 系统下安装(需要先安装git，如有直接执行下面命令) git clone --depth 1 https://github.com/wbthomason/packer.nvim\ ~/.local/share/nvim/site/pack/packer/start/packer.nvim Windows PowerShell 下安装 git clone https://github.com/wbthomason/packer.nvim &amp;#34;$env:LOCALAPPDATA vim-data\site\pack\packer\start\packer.nvim&amp;#34; 配置 packer 包管理器 安装后，我们需要新建文件~/.config/nvim/init.vim
这是 neovim 配置文件
mkdir -p ~/.config/nvim &amp;amp;&amp;amp; touch ~/.config/nvim/init.vim 然后再新建一个文件~/.config/nvim/lua/plugins.lua
这是packer管理插件的配置
mkdir -p ~/.config/nvim/lua &amp;amp;&amp;amp; touch ~/.config/nvim/lua/plugins.lua 然后编辑~/.config/nvim/init.vim配置，填入如下内容
lua require(&amp;#39;plugins&amp;#39;) 编辑~/.config/nvim/lua/plugins.lua，填入如下内容
vim.cmd [[packadd packer.nvim]] return require(&amp;#39;packer&amp;#39;).startup(function() -- Packer can manage itself use &amp;#39;wbthomason/packer.nvim&amp;#39; -- You add plugins here end) Done Packer 命令</description></item><item><title>neovim 配置 nvim-tree 文件树</title><link>https://blog.greycode.top/issues-blog/posts/19/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/19/</guid><description>安装 首先要先安装 nvim-tree.lua 和 nvim-web-devicons
老规矩,在 Packer 的配置里添加这两个的配置,一般文件路径在 ~/.config/nvim/lua/plugins.lua
use { &amp;#39;nvim-tree/nvim-tree.lua&amp;#39;, requires = { &amp;#39;nvim-tree/nvim-web-devicons&amp;#39;, -- optional, for file icons }, tag = &amp;#39;nightly&amp;#39; -- optional, updated every week. (see issue #1193) } 然后保存,并执行命令进行安装
$ nvim +PackerInstall 配置 nvim-tree 安装完成后,还要添加下 nvim-tree 的初始化配置文件 新建文件夹和文件
$ mkdir -p ~/.config/nvim/lua/plugin-config &amp;amp;&amp;amp; touch ~/.config/nvim/lua/plugin-config/nvim-tree.lua 在文件 ~/.config/nvim/lua/plugin-config/nvim-tree.lua 里填入如下配置
-- examples for your init.lua -- disable netrw at the very start of your init.lua (strongly advised) vim.</description></item><item><title>oci-go-sdk 配置文件创建流程</title><link>https://blog.greycode.top/issues-blog/posts/24/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/24/</guid><description>创建用户 首先在用户页面中创建一个 IAM 用户 然后创建一个组，把刚才创建的用户加进来 创建组的策略 对象存储用到的策略 写入权限 下载权限 预验证请求要用到的管理权限 创建 API KEY 在用户页面中，点击刚才创建的用户，进入这个用户的 profile 点击 API 密钥 点击 添加 API 密钥 然后选择生成 API 密钥对 下载私钥并保持到本地 点击添加后，将文本框的内容粘贴到 ~/.oci/config 文件中。 修改 ~/.oci/config 中 key_file 字段的值为你刚才保持私钥的路径 这样就可以使用 oci-go-sdk 了</description></item><item><title>VSCode 设置 markdown snippets</title><link>https://blog.greycode.top/issues-blog/posts/23/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/23/</guid><description>设置 Snippets 在 VSCode 界面按快捷键 Ctrl+Shift+P 打开命令输入框 在输入框中输入 Snippets, 并选择 Snippets: Configure User Snippets 在 Snippets 命令搜索框中输入 markdown, 打开 markdown snippets 配置 在 markdown,json 中输入你要的快捷补虫的文本片段, 比如我这边设置快捷注音 ruby 片段 { &amp;#34;Ruby of words&amp;#34;: { &amp;#34;prefix&amp;#34;: &amp;#34;ruby&amp;#34;, &amp;#34;body&amp;#34;: [ &amp;#34;&amp;lt;ruby&amp;gt;$1&amp;lt;rt&amp;gt;$2&amp;lt;/rt&amp;gt;&amp;lt;/ruby&amp;gt;&amp;#34; ], &amp;#34;description&amp;#34;: &amp;#34;Ruby of words&amp;#34; }, } 开启 markdown 代码片段补充 设置了 snippets 后，markdown 还是不能使用快捷补充功能的，还需要在 settings.json 中配置一下
还是使用 Ctrl+Shift+P 打开命令输入框，输入 settings ，选择 Prefernces: Open User Settings
在 json 配置中添加如下配置
&amp;#34;[markdown]&amp;#34;: { &amp;#34;editor.formatOnSave&amp;#34;: true, &amp;#34;editor.</description></item><item><title>电脑安装 anaconda 后，激活环境导致 zsh 主题失效解决方法</title><link>https://blog.greycode.top/issues-blog/posts/14/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/14/</guid><description>原因 系统: ArchLinux 终端shell: zsh 在安装 anaconda 后，激活环境后，zsh终端的主题就会失效
╭─zheng@zhengArch ~ ╰─$ conda activate base (base) 终端只剩下 conda 的环境名，当我退出 conda 环境是，zsh 主题还是不能恢复，必须重启终端才可以 退出环境：
╭─zheng@zhengArch ~ ╰─$ conda activate base (base) conda deactivate pwd /home/zheng 解决方法 执行如下命令可以解决
conda config --set changeps1 False 参考资料:
conda.io stackoverflow 美化 oh-my-zsh 主题 可以在 oh-my-zsh 主题配置文件里使用如下函数来获取当前 conda 环境名
# Conda info local conda_info=&amp;#39;$(conda_prompt_info)&amp;#39; conda_prompt_info() { if [ -n &amp;#34;$CONDA_DEFAULT_ENV&amp;#34; ]; then echo -n &amp;#34;($CONDA_DEFAULT_ENV) &amp;#34; else echo -n &amp;#34;&amp;#34; fi } bira.</description></item><item><title>高性能网关基石——OpenResty</title><link>https://blog.greycode.top/issues-blog/posts/15/</link><pubDate>Fri, 17 Mar 2023 14:58:23 +0800</pubDate><guid>https://blog.greycode.top/issues-blog/posts/15/</guid><description>什么是 OpenResty OpenResty 一个基于 Nginx 的高性能 Web 平台，能够方便地搭建处理超高并发的动态 Web 应用、 Web 服务和动态网关。例如有名的 Kong 网关和国产新秀 ApiSIX 网关都是基于 OpenResty 来进行打造的。
OpenResty 通过实现 ngx_lua 和 stream_lua 等 Nginx 模块，把 Lua/LuaJIT 完美地整合进了 Nginx，从而让我们能够在 Nginx 内部里嵌入 Lua 脚本，用 Lua 语言来实现复杂的 HTTP/TCP/UDP 业务逻辑，同时依然保持着高度的并发服务能力。
处理阶段 一个正常的 Web 服务的生命周期可以分成三个阶段：
initing：服务启动，读取配置文件，初始化内部数据结构 running：服务运行，接受客户端的请求，返回响应结果 exiting：服务停止，做一些必要的清理工作，如关闭监听端口 OpenResty 主要关注的是 initing 和 running 这两个阶段，并做了更细致的划分
OpenResty 的 initing 阶段 configuration：读取配置文件，解析配置指令，设置运行参数 master-initing：配置文件解析完毕，master 进程初始化公用的数据 worker-initing：worker 进程初始化自己专用的数据 OpenResty 的 running 阶段 在 running 阶段，收到客户端的请求后，OpenResty 对每个请求都会使用下面这条流水线进行处理：
ssl：SSL/TLS 安全通信和验证 preread： 在正式处理之前预读数据，接收 HTTP 请求头 rewrite：检查、改写 URI ，实现跳转重定向 access：访问权限控制 content：产生响应内容 filter：对 content 阶段产生的内容进行过滤加工处理 log： 请求处理完毕，记录日志，或者其他的收尾工作。 OpenResty 执行程序 OpenResty 根据上面的处理阶段提供了一些指令，在开发时使用它们就可以在这些阶段里面插入 Lua 代码，执行业务逻辑：</description></item></channel></rss>